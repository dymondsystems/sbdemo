<!-- The Modal -->
  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="modalTitle" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">

        <!-- Modal Header -->
       <div class="modal-header d-flex align-items-center">
  <img id="modalImage" src="" alt="Card Image" class="rounded-circle mr-2" style="width: 40px; height: 40px; display: none;">
  <h4 class="modal-title mb-0" id="modalTitle">Title</h4>
          
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>

        <!-- Modal Body -->
        <div class="modal-body" id="modalBody">
          <!-- Dynamically added buttons will appear here -->
          <div id="launch-buttons" class="mb-3">
            <!-- Buttons content will go here -->
          </div>

          
          
          

<div id="demo" class="collapse">
  <hr>
  <button data-toggle="collapse" class="btn btn-outline-secondary float-right" data-target="#demo"><i class="fas fa-minus"></i></button>
  <h3>Link folder</h3>
  <p>Drag buttons here...</p>
  
    <div class="card-body" id="collapsibleContainer">
      <!-- Buttons will be dragged here -->
    </div>
  </div>

          
          
          
          
          

          <!-- Add/Edit Button Form -->
           <!-- Modal Footer -->
        <div class="modal-footer" >
          <button data-toggle="collapse" class="btn btn-outline-secondary" data-target="#demo"><i class="fas fa-folder"></i></button>
          <button data-toggle="collapse" class="btn btn-outline-secondary" data-target="#demo2"><i class="fas fa-sticky-note"></i></button>
          <button data-toggle="collapse" class="btn btn-outline-secondary" data-target="#demo3"><i class="fas fa-thumbtack"></i></button>
          <button id="toggleFormButton" class="btn btn-outline-secondary" data-toggle="collapse" data-target="#addEditButton"><i class="fas fa-plus"></i></button>
         
          <button type="button" id="closeWindowButton" class="btn btn-secondary" data-dismiss="modal">Close</button>
          
          
          
          <div id="addEditButton" class="collapse mt-3" style="width:100%;">
            <form id="newButtonForm">
              <div class="form-group">
                <label for="buttonURL">Button URL:</label>
                <input type="url" class="form-control" id="buttonURL" required>
              </div>
              <div class="form-group">
                <label for="buttonName">Button Name:</label>
                <input type="text" class="form-control" id="buttonName" required>
              </div>
              
              <button type="submit" id="saveButton" class="btn btn-primary">Save</button>
               <button type="button" id="toggleFormButton" class="btn btn-secondary" data-toggle="collapse" data-target="#demo"><i class="fas fa-cog"></i></button>
              <button type="button" id="cancelButton" class="btn btn-secondary">Cancel</button>
  <div id="demo" class="collapse">
              <div class="form-group">
                <label>Open Link:</label><br>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="openType" id="openNewTab" value="newTab" checked>
                  <label class="form-check-label" for="openNewTab">In New Tab</label>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="openType" id="openNewWindow" value="newWindow">
                  <label class="form-check-label" for="openNewWindow">In New Window</label>
                </div>
              </div>
              <div id="windowSizeOptions" style="display:none;">
                <div class="form-group">
                  <label>Window Size:</label><br>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="windowSize" id="sizeSmall" value="small" checked>
                    <label class="form-check-label" for="sizeSmall">Small (600x400)</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="windowSize" id="sizeMedium" value="medium">
                    <label class="form-check-label" for="sizeMedium">Medium</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="windowSize" id="sizeLarge" value="large">
                    <label class="form-check-label" for="sizeLarge">Large</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="windowSize" id="sizeFull" value="full">
                    <label class="form-check-label" for="sizeFull">Full Screen</label>
                  </div>
                </div>
              </div>
              <div class="form-group">
                <button type="submit" id="saveButton" class="btn btn-primary">save settings</button>
                <button type="button" id="cancelButton" class="btn btn-secondary">Cancel</button>
            </div>
              </div>
            </form>
          </div>
        </div>

       

        </div>

      </div>
    </div>
  </div>
</div>





Close but doesnt load buttons

// Select modal-related elements
const launchButtonsContainer = document.getElementById('launch-buttons');
  const collapsibleContainer = document.getElementById('collapsibleContainer');
const newButtonForm = document.getElementById('newButtonForm');
const toggleFormButton = document.getElementById('toggleFormButton');
const saveButton = document.getElementById('saveButton');
const cancelButton = document.getElementById('cancelButton');
let currentModal = null;
let editingButton = null;
let openedWindow = new Map(); // Track the opened window

// Load buttons for a specific modal
function loadButtons(modalId) {
  launchButtonsContainer.innerHTML = '';  // Clear current buttons
  
  const buttons = JSON.parse(localStorage.getItem(`launchButtons_${modalId}`)) || [];
  buttons.forEach(button => createButton(button));
}

// Load buttons for the collapsible container
function loadCollapsibleContainerButtons() {
  collapsibleContainer.innerHTML = ''; // Clear current buttons
  const buttons = JSON.parse(localStorage.getItem('collapsibleContainerButtons')) || [];
  buttons.forEach(button => createButton(button, collapsibleContainer));
}


// Open a new window based on the selected size
function openWindow(url, size) {
  let width, height, left, top;

  switch (size) {
    case 'small':
      width = screen.width * 0.4;
      height = screen.height * 0.4;
      break;
    case 'medium':
      width = screen.width * 0.6;
      height = screen.height * 0.6;
      break;
    case 'large':
      width = screen.width * 0.8;
      height = screen.height * 0.8;
      break;
    case 'full':
      width = screen.width * 1.0;
      height = screen.height * 1.0;
      break;
    default:
      width = screen.width * 0.5;
      height = screen.height * 0.5;
  }

  left = (screen.width - width) / 2;
  top = (screen.height - height) / 2;

  const newWin = window.open(url, '_blank', `width=${width},height=${height},top=${top},left=${left}`);

  if (newWin) {
    openedWindows.set(url, newWin); // Store reference
    newWin.onbeforeunload = () => openedWindows.delete(url); // Remove when closed
  }

  return newWin;
}

// Initialize Sortable.js for launch buttons
const sortableLaunchButtons = new Sortable(launchButtonsContainer, {
  animation: 150,
  handle: '.launch-button', // Drag handle
  group: {
    name: 'shared', // Same group name for both containers
    pull: true, // Allow dragging from this container
    put: true // Allow dropping into this container
  },
  onEnd: function (evt) {
    if (currentModal) {
      saveButtons(currentModal); // Save the new order for launchButtonsContainer
    }
  }
});

// Initialize Sortable.js for collapsible container
const sortableCollapsibleContainer = new Sortable(collapsibleContainer, {
  animation: 150,
  group: {
    name: 'shared', // Same group name for both containers
    pull: true, // Allow dragging from this container
    put: true // Allow dropping into this container
  },
  onEnd: function (evt) {
    saveCollapsibleContainerButtons(); // Save the state of the collapsible container
  }
});

// Save buttons for a specific modal
function saveButtons(modalId) {
  const buttons = [];
  document.querySelectorAll('#launch-buttons .launch-button').forEach(btn => {
    buttons.push({
      url: btn.dataset.url,
      name: btn.dataset.name,
      size: btn.dataset.size,
      openType: btn.dataset.openType
    });
  });
  localStorage.setItem(`launchButtons_${modalId}`, JSON.stringify(buttons));
}

// Save buttons for the collapsible container
function saveCollapsibleContainerButtons() {
  const buttons = [];
  document.querySelectorAll('#collapsibleContainer .launch-button').forEach(btn => {
    buttons.push({
      url: btn.dataset.url,
      name: btn.dataset.name,
      size: btn.dataset.size,
      openType: btn.dataset.openType
    });
  });
  localStorage.setItem('collapsibleContainerButtons', JSON.stringify(buttons));
}

// Load buttons for both containers on page load
document.addEventListener('DOMContentLoaded', () => {
  if (currentModal) {
    loadButtons(currentModal);
  }
  loadCollapsibleContainerButtons();
});

// Open modal
$('#myModal').on('show.bs.modal', function (e) {
  currentModal = $(e.relatedTarget).data('modal'); // Get modal ID
  loadButtons(currentModal);
});

// Add or edit button
newButtonForm.onsubmit = (e) => {
  e.preventDefault();
  const url = document.getElementById('buttonURL').value;
  const name = document.getElementById('buttonName').value;
  const size = document.querySelector('input[name="windowSize"]:checked').value;
  const openType = document.querySelector('input[name="openType"]:checked').value;

  if (editingButton) {
    // Update existing button
    editingButton.dataset.url = url;
    editingButton.dataset.name = name;
    editingButton.dataset.size = size;
    editingButton.dataset.openType = openType;
    editingButton.innerHTML = `<i class='fa fa-external-link'></i><br>${name}`;
    editingButton = null;
    saveButton.textContent = 'Add';
  } else {
    // Create new button
    createButton({ url, name, size, openType }, launchButtonsContainer);
  }

  // Save the updated buttons and refresh the list
  saveButtons(currentModal);
  loadButtons(currentModal);
  newButtonForm.reset();
  $('#addEditButton').collapse('hide');
  $('#demo').collapse('hide');
};

// Edit button
function editButton(el) {
  const button = el.closest('.btn-group').querySelector('.launch-button');
  document.getElementById('buttonURL').value = button.dataset.url;
  document.getElementById('buttonName').value = button.dataset.name;
  document.querySelector(`input[value="${button.dataset.size}"]`).checked = true;
  document.querySelector(`input[value="${button.dataset.openType}"]`).checked = true;
  editingButton = button;
  saveButton.textContent = 'Save';
  $('#addEditButton').collapse('show');
}

// Remove button
function removeButton(el) {
  const buttonDiv = el.closest('.btn-group');
  buttonDiv.remove();
  if (buttonDiv.parentElement === launchButtonsContainer) {
    saveButtons(currentModal);
  } else if (buttonDiv.parentElement === collapsibleContainer) {
    saveCollapsibleContainerButtons();
  }
}

// Cancel button
cancelButton.onclick = () => {
  newButtonForm.reset();
  editingButton = null;
  saveButton.textContent = 'Add';
  $('#addEditButton').collapse('hide');
  $('#demo').collapse('hide');
};

// Close all windows when the modal is hidden (if auto-close is enabled)
$('#myModal').on('hidden.bs.modal', function () {
  const autoCloseEnabled = JSON.parse(localStorage.getItem("autoCloseWindows")) || false;

  if (autoCloseEnabled) {
    // Loop through all stored windows and close them
    openedWindows.forEach((win, url) => {
      if (win && !win.closed) {
        win.close();
      }
    });

    // Clear the map after closing all windows
    openedWindows.clear();
  }
});





Updated version, possible dataleak fix

// Select modal-related elements
const launchButtonsContainer = document.getElementById('launch-buttons');
const collapsibleContainer = document.getElementById('collapsibleContainer');
const newButtonForm = document.getElementById('newButtonForm');
const toggleFormButton = document.getElementById('toggleFormButton');
const saveButton = document.getElementById('saveButton');
const cancelButton = document.getElementById('cancelButton');
let currentModal = null;
let editingButton = null;
const openedWindows = new Map(); // Track the opened windows

// Function to create and append a button to the specified container
function createButton(buttonData, container = null) {
  // Determine which container to use
  const targetContainer = container || launchButtonsContainer;
  
  const buttonDiv = document.createElement('div');
  buttonDiv.className = 'btn-group mb-2';

  const button = document.createElement('button');
  button.className = 'btn btn-sq-lg btn-outline-primary launch-button';
  button.dataset.url = buttonData.url;
  button.dataset.name = buttonData.name;
  button.dataset.size = buttonData.size;
  button.dataset.openType = buttonData.openType;
  button.innerHTML = `<i class='fa fa-external-link-alt'></i><br>${buttonData.name}`;

  button.onclick = () => {
    const refocusEnabled = JSON.parse(localStorage.getItem('refocusExistingWindows')) || false;

    if (refocusEnabled && openedWindows.has(buttonData.url)) {
      const existingWindow = openedWindows.get(buttonData.url);
      if (existingWindow && !existingWindow.closed) {
        existingWindow.focus();
        return; // Stop here, no need to open a new window
      }
    }

    if (buttonData.openType === 'newTab') {
      window.open(buttonData.url, '_blank');
    } else {
      const newWindow = openWindow(buttonData.url, buttonData.size);
      openedWindows.set(buttonData.url, newWindow); // Track the opened window
    }
  };

  const dropdown = document.createElement('div');
  dropdown.className = 'dropdown';
  dropdown.innerHTML = `    
    <button class="btn btn-outline-secondary dropdown-toggle" data-toggle="dropdown"></button>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="#" onclick="stickToTopButton(this, 'window')"><i class="far fa-sticky-note"></i> Stick to Top</a>
      <a class="dropdown-item" href="#" onclick="editButton(this)"><i class="fas fa-edit"></i> Edit</a>
      <a class="dropdown-item" href="#" onclick="setShortcut(this)"><i class="fas fa-keyboard"></i> Set Shortcut</a>
      <a class="dropdown-item text-danger" href="#" onclick="removeButton(this)"><i class="fas fa-trash-alt"></i> Remove</a>
    </div>`;

  buttonDiv.appendChild(button);
  buttonDiv.appendChild(dropdown);
  targetContainer.appendChild(buttonDiv);
}

// Load buttons for a specific modal
function loadButtons(modalId) {
  launchButtonsContainer.innerHTML = '';  // Clear current buttons

  // Predefined buttons for each modal
  const predefinedButtons = {
    1: [
      { url: 'https://promptgpt.stackboard.one/', name: 'Open promptGPT', size: 'medium', openType: 'newWindow' }
    ],
    2: [
      { url: 'https://chatgpt.com', name: 'Launch chatGPT', size: 'medium', openType: 'newTab' }
    ],
    3: [
      { url: 'https://github.com', name: 'github home', size: 'large', openType: 'newTab' }
    ]
  };

  // Get predefined buttons and saved buttons from localStorage
  const predefined = predefinedButtons[modalId] || [];
  const savedButtons = JSON.parse(localStorage.getItem(`launchButtons_${modalId}`)) || [];

  // Merge and avoid duplicates by filtering out already existing buttons (based on URL)
  const allButtons = [
    ...predefined.filter(p => !savedButtons.some(s => s.url === p.url)),
    ...savedButtons
  ];

  // Create buttons from the merged list
  allButtons.forEach(button => createButton(button));
}

// Load buttons for the collapsible container
function loadCollapsibleContainerButtons() {
  collapsibleContainer.innerHTML = ''; // Clear current buttons
  const buttons = JSON.parse(localStorage.getItem('collapsibleContainerButtons')) || [];
  buttons.forEach(button => createButton(button, collapsibleContainer));
}

// Save buttons for a specific modal
function saveButtons(modalId) {
  const buttons = [];
  document.querySelectorAll('#launch-buttons .launch-button').forEach(btn => {
    buttons.push({
      url: btn.dataset.url,
      name: btn.dataset.name,
      size: btn.dataset.size,
      openType: btn.dataset.openType
    });
  });
  localStorage.setItem(`launchButtons_${modalId}`, JSON.stringify(buttons));
}

// Save buttons for the collapsible container
function saveCollapsibleContainerButtons() {
  const buttons = [];
  document.querySelectorAll('#collapsibleContainer .launch-button').forEach(btn => {
    buttons.push({
      url: btn.dataset.url,
      name: btn.dataset.name,
      size: btn.dataset.size,
      openType: btn.dataset.openType
    });
  });
  localStorage.setItem('collapsibleContainerButtons', JSON.stringify(buttons));
}

// Open a new window based on the selected size
function openWindow(url, size) {
  let width, height, left, top;

  switch (size) {
    case 'small':
      width = screen.width * 0.4;
      height = screen.height * 0.4;
      break;
    case 'medium':
      width = screen.width * 0.6;
      height = screen.height * 0.6;
      break;
    case 'large':
      width = screen.width * 0.8;
      height = screen.height * 0.8;
      break;
    case 'full':
      width = screen.width * 1.0;
      height = screen.height * 1.0;
      break;
    default:
      width = screen.width * 0.5;
      height = screen.height * 0.5;
  }

  left = (screen.width - width) / 2;
  top = (screen.height - height) / 2;

  const newWin = window.open(url, '_blank', `width=${width},height=${height},top=${top},left=${left}`);

  if (newWin) {
    openedWindows.set(url, newWin); // Store reference
    newWin.onbeforeunload = () => openedWindows.delete(url); // Remove when closed
  }

  return newWin;
}

// Initialize Sortable.js for launch buttons
document.addEventListener('DOMContentLoaded', () => {
  if (typeof Sortable !== 'undefined') {
    const sortableLaunchButtons = new Sortable(launchButtonsContainer, {
      animation: 150,
      handle: '.launch-button', // Drag handle
      group: {
        name: 'shared', // Same group name for both containers
        pull: true, // Allow dragging from this container
        put: true // Allow dropping into this container
      },
      onEnd: function (evt) {
        if (currentModal) {
          saveButtons(currentModal); // Save the new order for launchButtonsContainer
        }
      }
    });

    // Initialize Sortable.js for collapsible container
    const sortableCollapsibleContainer = new Sortable(collapsibleContainer, {
      animation: 150,
      group: {
        name: 'shared', // Same group name for both containers
        pull: true, // Allow dragging from this container
        put: true // Allow dropping into this container
      },
      onEnd: function (evt) {
        saveCollapsibleContainerButtons(); // Save the state of the collapsible container
      }
    });
  }
});

// Function to remove a button
function removeButton(element) {
  const buttonDiv = element.closest('.btn-group');  // Get the parent .btn-group of the clicked button
  const button = buttonDiv.querySelector('.launch-button');
  const url = button.dataset.url;
  
  // Check which container the button belongs to
  const parentContainer = buttonDiv.parentElement;
  
  // Remove from DOM
  buttonDiv.remove();

  if (parentContainer === launchButtonsContainer && currentModal) {
    // Remove from modal buttons in localStorage
    let savedButtons = JSON.parse(localStorage.getItem(`launchButtons_${currentModal}`)) || [];
    savedButtons = savedButtons.filter(button => button.url !== url);
    localStorage.setItem(`launchButtons_${currentModal}`, JSON.stringify(savedButtons));
  } else if (parentContainer === collapsibleContainer) {
    // Remove from collapsible container buttons in localStorage
    let savedButtons = JSON.parse(localStorage.getItem('collapsibleContainerButtons')) || [];
    savedButtons = savedButtons.filter(button => button.url !== url);
    localStorage.setItem('collapsibleContainerButtons', JSON.stringify(savedButtons));
  }
}

// Edit button
function editButton(element) {
  const button = element.closest('.btn-group').querySelector('.launch-button');
  document.getElementById('buttonURL').value = button.dataset.url;
  document.getElementById('buttonName').value = button.dataset.name;
  document.querySelector(`input[value="${button.dataset.size}"]`).checked = true;
  document.querySelector(`input[value="${button.dataset.openType}"]`).checked = true;
  
  // Add a checkbox to determine if we're editing a collapsible container button
  const isCollapsible = button.closest('#collapsibleContainer') !== null;
  if (document.getElementById('targetCollapsible')) {
    document.getElementById('targetCollapsible').checked = isCollapsible;
  }
  
  editingButton = button;
  saveButton.textContent = 'Save';
  $('#addEditButton').collapse('show');
}

// Add or edit button
newButtonForm.onsubmit = (e) => {
  e.preventDefault();
  const url = document.getElementById('buttonURL').value;
  const name = document.getElementById('buttonName').value;
  const size = document.querySelector('input[name="windowSize"]:checked').value;
  const openType = document.querySelector('input[name="openType"]:checked').value;
  
  // Determine target container (if the checkbox exists)
  const targetCollapsible = document.getElementById('targetCollapsible')?.checked || false;
  const targetContainer = targetCollapsible ? collapsibleContainer : launchButtonsContainer;

  if (editingButton) {
    // Update existing button
    editingButton.dataset.url = url;
    editingButton.dataset.name = name;
    editingButton.dataset.size = size;
    editingButton.dataset.openType = openType;
    editingButton.innerHTML = `<i class='fa fa-external-link-alt'></i><br>${name}`;
    
    // Save updates to appropriate storage
    if (editingButton.closest('#collapsibleContainer')) {
      saveCollapsibleContainerButtons();
    } else if (currentModal) {
      saveButtons(currentModal);
    }
    
    editingButton = null;
    saveButton.textContent = 'Add';
  } else {
    // Create new button in the appropriate container
    createButton({ url, name, size, openType }, targetContainer);
    
    // Save to appropriate storage
    if (targetContainer === collapsibleContainer) {
      saveCollapsibleContainerButtons();
    } else if (currentModal) {
      saveButtons(currentModal);
    }
  }

  newButtonForm.reset();
  $('#addEditButton').collapse('hide');
  $('#demo').collapse('hide');
};

// Cancel button
cancelButton.onclick = () => {
  newButtonForm.reset();
  editingButton = null;
  saveButton.textContent = 'Add';
  $('#addEditButton').collapse('hide');
  $('#demo').collapse('hide');
};

// Function to set a keyboard shortcut
function setShortcut(element) {
  const buttonDiv = element.closest('.btn-group');
  const button = buttonDiv.querySelector('.launch-button');

  // Prompt the user to enter a shortcut key
  const shortcut = prompt('Enter a keyboard shortcut (e.g., "Ctrl+Shift+K"):');
  if (shortcut) {
    button.dataset.shortcut = shortcut;
    
    // Save the shortcut to localStorage
    const shortcuts = JSON.parse(localStorage.getItem("shortcuts")) || {};
    shortcuts[shortcut] = {
      url: button.dataset.url,
      openType: button.dataset.openType
    };
    localStorage.setItem("shortcuts", JSON.stringify(shortcuts));
    
    alert(`Shortcut "${shortcut}" set for "${button.dataset.name}"`);
  }
}

// Load buttons for both containers on page load and set up event listeners
document.addEventListener('DOMContentLoaded', () => {
  // Load collapsible container buttons
  loadCollapsibleContainerButtons();
  
  // Set up the modal event listener
  $('#myModal').on('show.bs.modal', function (e) {
    currentModal = $(e.relatedTarget).data('modal'); // Get modal ID
    loadButtons(currentModal);
  });
  
  // Close all windows when the modal is hidden (if auto-close is enabled)
  $('#myModal').on('hidden.bs.modal', function () {
    const autoCloseEnabled = JSON.parse(localStorage.getItem("autoCloseWindows")) || false;

    if (autoCloseEnabled) {
      // Loop through all stored windows and close them
      openedWindows.forEach((win, url) => {
        if (win && !win.closed) {
          win.close();
        }
      });

      // Clear the map after closing all windows
      openedWindows.clear();
    }
  });
  
  // Set up auto-close toggle
  const autoCloseToggle = document.getElementById("autoCloseWindowsToggle");
  if (autoCloseToggle) {
    // Load saved state
    const autoCloseEnabled = JSON.parse(localStorage.getItem("autoCloseWindows")) || false;
    autoCloseToggle.checked = autoCloseEnabled;

    // Save state when toggled
    autoCloseToggle.addEventListener("change", () => {
      localStorage.setItem("autoCloseWindows", autoCloseToggle.checked);
    });
  }
  
  // Set up refocus toggle
  const refocusToggle = document.getElementById('windowBehaviorToggle');
  if (refocusToggle) {
    refocusToggle.checked = JSON.parse(localStorage.getItem('refocusExistingWindows')) || false;

    refocusToggle.addEventListener('change', (event) => {
      localStorage.setItem('refocusExistingWindows', event.target.checked);
    });
  }
  
  // Set up shortcut refocus toggle
  const shortcutRefocusToggle = document.getElementById("shortcutBehaviorToggle");
  if (shortcutRefocusToggle) {
    // Load the setting from localStorage
    shortcutRefocusToggle.checked = JSON.parse(localStorage.getItem("refocusShortcutWindows")) || false;

    // Save the setting when toggled
    shortcutRefocusToggle.addEventListener("change", (event) => {
      localStorage.setItem("refocusShortcutWindows", event.target.checked);
    });
  }
});

// Listen for keyboard shortcuts
document.addEventListener("keydown", (event) => {
  const shortcuts = JSON.parse(localStorage.getItem("shortcuts")) || {};
  const refocusEnabled = JSON.parse(localStorage.getItem("refocusShortcutWindows")) || false;

  for (const shortcut in shortcuts) {
    if (checkShortcut(event, shortcut)) {
      event.preventDefault();
      const { url, openType } = shortcuts[shortcut];

      // Retrieve latest size setting from the button dataset
      const button = document.querySelector(`.launch-button[data-url="${url}"]`);
      const size = button ? button.dataset.size : "medium"; // Default to medium if not found

      if (refocusEnabled && openedWindows.has(url)) {
        const existingWindow = openedWindows.get(url);
        if (existingWindow && !existingWindow.closed) {
          existingWindow.focus();
          return; // Stop execution if refocus was successful
        }
      }

      // If refocusing fails or is disabled, open a new window
      if (openType === "newTab") {
        window.open(url, "_blank");
      } else {
        const newWindow = openWindow(url, size);
        openedWindows.set(url, newWindow); // Track new window
      }
    }
  }
});

// Helper function to check if the pressed keys match the shortcut
function checkShortcut(event, shortcut) {
  const keys = shortcut.split('+');
  const modifiers = {
    ctrl: event.ctrlKey,
    shift: event.shiftKey,
    alt: event.altKey,
    meta: event.metaKey,
  };

  for (const key of keys) {
    const lowerKey = key.toLowerCase();
    if (lowerKey === 'ctrl' || lowerKey === 'shift' || lowerKey === 'alt' || lowerKey === 'meta') {
      if (!modifiers[lowerKey]) return false;
    } else {
      if (event.key.toLowerCase() !== lowerKey) return false;
    }
  }
  return true;
}

// Function to stick button to top (placeholder)
function stickToTopButton(element, type) {
  // Implement your sticky functionality here
  alert('Sticky button feature coming soon!');
}

